"""This class teaches students how to manage users, groups and permissions in a Linux enviornment.
Topics Covered

Adding and Deleting Users
Editing the passwd File Which Contains User Configurations
Changing User Passwords
Adding and Deleting Groups
Adding and Deleting Users from Groups
Editing the group Configuration File
Understanding Permission Numbering System
Changing User and Group Ownership for Files and Folders
Class Notes"""


Users
Add User = sudo adduser [username]
Change User password = sudo passwd [username]
Delete User = sudo userdel [username]
Edit Users Configuration File = sudo vim /etc/passwd (shows usernames, names of users, home directories)
Groups
Sudo groupadd [groupname]
Sudo groupdel [groupname]
Sudo vim /etc/group (shows groups and users)

Permissions
Numbers = owner/group/everyone else
4 = read, 2 = write, 1 = execute

To Chanege Permissions of a File or Folder = sudo chmod 777 file/folder (-R for recursive)

Changing Ownership

To Change User Ownership = sudo chown -R [username] file/folder
To Change Group Ownership =sudo chgrp --R [groupname] file/folder
-R for Recursive for Folders


""" This is a resource file to refresh how to correctly use vim editor"""
in terminal shell prompt:$ vimtutor

######################################################################################

HOW TO RESET/RECOVER ROOT PASSWORD (RED HAT LINUX)

1. Reboot machine 
# At GRUB bootloader
When prompt to select OS press 'e'(for edit mode)

2. Locate the kernel line and navigate to the end of the line.
Add 'rd.break' (Ram Disk break)

3. Continue with bootup by pressing ctrl+x

4. mount -o remount,rw /sysroot
chroot /sysroot
passwd
typed password twice
touch /.autorelabel
exit﻿

######################################################################################

HOW TO RESET/RECOVER ROOT/USER PASSWORD (Ubuntu 16.04)

# This was performed and successful on my infoset-ng server (andre@suerte) 
# IP address 10.0.0.100

1. Reboot the system
- At the GRUB menu quickly press 'e' to enter edit mode on the kernel.

2. Find the line beginning with 'linux' and place cursor there, press 'end' key to jump to the end of the line. (you should see 'ro' as the last command (this stands for 'read only')

TWO OPTIONS TO CONTINUE:

OPTION 1: Delete everything after 'ro'(sometimes it will say splash screen....) and append the following:

# this is what you should see
root=/dev/mapper/<$HOSTNAME>--vg-root ro
root=/dev/mapper/suerte--vg-root ro

# add this:
root=/dev/mapper/suerte--vg-root rw init=/bin/bash

Press ctrl+x to continue reboot

You will now be in /bin/bash as root like so:
root@(None):/# 

Here you can reset the password
1. FOR CHANGE OF ROOT PW
passwd root

2. FOR CHANGE OF A SPECIFIC USER
passwd <user_name> (e.g archie)

You will then be prompt to enter the NEW unix PS and confirm it

Type : sync 
to apply the changes
sync - Synchronize cached writes to persistent storage

Exit by running:
exit

****************************
OPTION 2:

1. Reboot the system
- At the GRUB menu quickly press 'e' to enter edit mode on the kernel.

2. Find the line beginning with 'linux' and place cursor there, press 'end' key to jump to the end of the line. (you should see 'ro' as the last command (this stands for 'read only')

# this is what you should see
root=/dev/mapper/<$HOSTNAME>--vg-root ro
root=/dev/mapper/suerte--vg-root ro

3. Now instead of deleting anything we can just add to at the end like so:

root=/dev/mapper/<$HOSTNAME>--vg-root ro init=/bin/bash

4. Press ctrl+x to continue boot

5. Here is where it differs from OPTION 1
- at the moment we don't have the ability to 'write' on the file system, only 'read'(ro)
- you can verify this by running:
mount 

Output: /dev sda1 on / type ext4 (ro,relatime,data=ordered)

To write to the file system:
mount -o remount,rw / 
this allows us to now read and write to the file system at / (root).

check that you have ability to 'rw'
Output: /dev sda1 on / type ext4 (rw,relatime,data=ordered)

Here you can reset the password
1. FOR CHANGE OF ROOT PW
passwd root

2. FOR CHANGE OF A SPECIFIC USER
passwd <user_name> (e.g archie)

You will then be prompt to enter the NEW unix PS and confirm it

Type : sync 
to apply the changes
sync - Synchronize cached writes to persistent storage



###############################################################################################
How can we change root password
Here are a few ways I can think of, from the least intrusive to the most intrusive.

Without Rebooting
With sudo: if you have sudo permissions to run passwd, you can do:

$ sudo passwd root

Enter your password, then enter a new password for root twice. Done.

Editing files: this works in the unlikely case you don't have full sudo access, but you do have access to edit /etc/{passwd,shadow}. Open /etc/shadow, either with sudoedit /etc/shadow, or with sudo $EDITOR /etc/shadow. Replace root's password field (all the random characters between the second and third colons :) with your own user's password field. Save. The local has the same password as you. Log in and change the password to something else.

###############################################################################################

HOW TO LIST ALL USERS ON SYSTEM WITH A HOME DIRECTORY

1. Run as Root
2. # cat /etc/passwd | grep /home*


##############################################################################################

***PRACTICE RHCSA QUESTIONS***

1. Set up an account for a new System Administrator, Jason, who has just joined your team. His full name is Jason Doe, his shell is bash, he is a member of a new group called admin. His user quota at /home is 100Mb.Jason can execute any command as root but has to supply his own password at each request.


1.Run as Root (su -)

2. # create the group admin with a gid(group ID) of 601
command: groupadd -g 601 admin

3. # add the user to group 601, allow shell access in /bin/bash, add a home directory at /home/jason, -c comment full name

command: useradd -g 601 -s /bin/bash -d /home/jason -c "Jason Doe" jason

###########################################################################################################

How to search the linux repository for a specific program name:
# use this command to search for what you think a program is called. 
apt-cache will return similar results to help you determine the exact name of the program you are looking for along with a short description.
# be sure to use a (*) at the end of the program name to include 'all' files 
when searching.

	$ sudo apt-cache search <name of program*>
	$ sudo apt-cache search Django*

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# To repeat the previous command use:

	$ sudo !!

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# To switch users use:

	$ su <name of user>
	$ su carolina
	$ su andre

# To change to Root user use:

	# 'Super user do, super user'.
	$ sudo su

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# To manage packages/install, remove, update, and upgrade  use the 'apt-get' program
# command usage: sudo apt-get <action> <file or program you want action performed on>
# example:
	$ sudo apt-get install <name of program(package)>
	$ sudo apt-get install bluefish

# To remove a program use:
	$ sudo apt-get remove <name of program(package)>
	$ sudo apt-get remove bluefish

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# To make a 'matrix' style effect on command line use this:

	$ while (true) do echo -n "your message"; done

# To kill task: ctrl z

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# To check if a program or specific package is install on your local machine use:

	$ apt-cache policy <name of program>
	$ apt-cache policy python3
	output:
		python3:
			Installed: 3.5.1-3
			Candidate: 3.5.1-3
		Version table:
			*** 3.5.1-3 500
			500 http://us.archive.ubuntu.com/ubuntu xenial/main amd64 Packages
			100 /var/lib/dpkg/status

# This will tell you if it exists on the machine and where it is installed.

# To check a known non-exsistant program output look like the following:
	$ apt-cache policy bluefish
	output:
		bluefish:
		  Installed: (none)
		  Candidate: 2.2.7-2
		Version table:
		2.2.7-2 500
		500 http://us.archive.ubuntu.com/ubuntu xenial/universe amd64 Packages

# Installed = NONE

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# FILE PERMISSIONS AND FILE OWNERSHIP
--------------------------------------

USE:  
	$ ls -l (list with 'long view) 
to show files with permissions and user/groups

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

drwxrwxr-x 2 andre andre  4096 Jun 17 17:44 Command_Line_Notes

In the order of output:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-rwxrw-r--    1    root   root 2048    Jan 13 07:11 afile.exe
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-file permissions (drwxrwxr)
number of links (1)
owner name (root)
owner group (root)
file size (2048)
time of last modification, and
file/directory name (Jan 13 07:11 <name of file/directory>

File permissions is displayed as following:

first character is - or l or d
d-  indicates a directory.
a line(hyphen) represents a file.
l-  is a symlink (or soft link) - special type of file.

three sets of characters, three times, indicating permissions for owner, group and other:
r = readable
w = writable
x = executable

In the example out put above -rwxrw-r--, this means the line displayed is:

a regular file (displayed as -)
readable, writable and executable by owner (rwx)
readable, writable, but not executable by group (rw-)
readable but not writable or executable by other (r--)


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



# chown = 'Change ownership' - change to a specific user or 'Root'
command:
	$ chown user:group <name of file/directory> (can also specify a direct path (usr/env<name of file>)

# chmod = 'Change permissions' - allowing what can and can not be done to a specific file or directory.

NOTE**** You can add -R to both chown, and chmod to make the command recursive to all files in a directory.

EXAMPLE:
	chown -R user:group <name of directory>

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Command syntax[edit]

	$ chmod [options] mode[,mode] file1 [file2 ...][3]

Usual implemented options include:

-R recursive, i.e. include objects in subdirectories
-f force, forge ahead with all objects even if errors occur
-v verbose, show objects processed
If a symbolic link is specified, the target object is affected. File modes directly associated with symbolic links themselves are typically never used.

To view the file mode, the ls or stat commands may be used:

$ ls -l findPhoneNumbers.sh

-rwxr-xr--  1 dgerman  staff  823 Dec 16 15:03 findPhoneNumbers.sh
$ stat -c %a findPhoneNumbers.sh

754

The r, w, and x specify the read, write, and execute access, respectively. The first character of the ls display denotes the object type;
a hyphen represents a plain file. This script can be read, written to, and executed by the owner, read and executed by other members of the staff group and can also be read by others.

Octal modes[edit]
See also: Octal notation of file system permissions

The chmod numerical format accepts up to four octal digits. 
The three rightmost digits refer to permissions for the file owner, the group, and other users.
The optional leading digit, when 4 digits are given, specifies the special setuid, setgid, and sticky flags.

Numerical permissions

#	Permission	rwx
7	read, write and execute	rwx
6	read and write	rw-
5	read and execute	r-x
4	read only	r--
3	write and execute	-wx
2	write only	-w-
1	execute only	--x
0	none	---
Numeric example[edit]
In order to permit all users who are members of the programmers group to update a file

	$ ls -l sharedFile

-rw-r--r--  1 jsmith programmers 57 Jul  3 10:13  sharedFile
	$ chmod 664 sharedFile
	$ ls -l sharedFile

-rw-rw-r--  1 jsmith programmers 57 Jul  3 10:13  sharedFile
Since the setuid, setgid and sticky bits are not specified, this is equivalent to:

	$ chmod 0664 sharedFile

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Creating New files, directories. Removing and deleting files/directories

Commands:

	$ touch - creates files
EXAMPLE:
	$ touch <nameoffile.extension_type>

	$ touch file.txt file2.txt file3.txt file.py file4.cpp file5.html file6.html
** This creates 6 new files

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

mkdir(make directory)- creates a new empty directory

cp(copy)- how to copy files to a new location

	$ cp <name of target file> <specific directory path>
	$ cp pythonNotes /Documents/tutorials/python

** WHEN INSIDE OF SPECIFIC DIRECTORY**
rm(remove)- removes files and directories
	$ rm file.txt

To remove all files from a directory but keep the directory use:
	$ rm ./*

To remove all files with a specific file extension use:
	$ rm ./*.<extension_type>
	$ rm ./*.html

** WHEN NOT IN SPECIFIC DIRECTORY **

To remove all file from a directory but keep the directory use:
	$ rm <nameofdirectory>/*
	$ rm Documents/*

To remove the directory use:
	$ rm -rf <nameofdirectory>
	$ rm -rf schoolnotes

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# To move a file use:
	$ mv filename <destination>
	$ mv file1.txt /Documents/newdir

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FIND COMMAND***
~~~~~~~~~~~~~~~~~

# use this to find specific files, file extensions, file sizes, as well as specific directories.

Command:
	$ find . -type f -iname "*.html"
	
	# you can also specify a specific directory in the search like so
	# This command reads as: 
		find in the /etc directory all file types, ignore case and return all with a .conf extension.
	$ find /etc -type f -iname "*.conf"



$ find . -type f -iname "*.html"

find = command
. = in the current directory
-type f = the type we are searching for is 'f' for file.
-iname = means to ignore case (upper/lower) this will return all
"" = name of specific file or name of specific extension type
* = wild card for searching for ALL

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

GREP Command***
~~~~~~~~~~~~~~~~~

# Use grep to find specific items within a file

Command:
	$ grep <"what you are looking for> <name of file to look in>
	$ grep "function" file1.py

# Search all files within current directory, ignoring case(case insensitive)
	$ grep -i "function" ./*


***USE THIS COMMAND TO SEARCH FOR MOST INSTANCES WITHIN A FILE****
# Search and return with line number where instances of the search string are found.
	$ grep -i -n "config" ./*


# *** YOU CAN ALSO USE GREP IN CONJUNCTION WITH THE 'FIND' COMMAND***

	# you can run a find command as normal and at the end of the command add the flag -exec(execute)
	# -exec takes the grep command argument
	# at the end of your grep command you need to end the statement with {} +


	# this will search and find and return...
	$ find . -type f -iname "*.php" -exec grep -i -n "config" {} +

		-find in the current directory
		-all file types
		-ignoring case(case insensitive)
		-search all with .php extentions
		THEN
		- Execute grep
		- ignoring case
		- show line numbers
		- return 'config' as search
		- {} + end the execute statement

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Redirect the output of a command to a file by printing and creating a file to add output in.
	- you do this by running the command on the output source
	Example:
		$ find . -type f -size -20k -iname "*.py" -exec grep -i -n "config" {} + | tee drelog.txt

	# This searches the current directory looking for files less than 20 kilobytes with the .py extention. 
	# Then executes grep case insensitive, displaying line numbers searching for string 'config' 
	# Then it pipes the result into a file named 'drelog.txt' as well as prints the output to the screen.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# PROCESSES

# Use 'top' or 'htop' to view in real-time current processes.

# To view all background tasks use the command:
	$ ps aux

# To view a specific app or program use ps aux and pipe the app or program as the argument.
	$ ps aux | python3

# To view processor ID's (PID) use the command pgrep.
	$ pgrep chrome

# To kill a single app or process use grep to return the proccessor id and then kill it based on it's id.
	$ pgrep chrome
		output:
		1568
		3369
		1497
		7812
	# To kill a specific process use this command.
		$ kill -9 1497

# Likewise to kill all of the proccesses use:
	$ killall chrome

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. Why you don't have a root password

While you can create a password for the superuser account allowing you to log in as root with su, it's worth mentioning that this isn't the "Ubuntu" way of doing things. Ubuntu have specifically chosen not to give a root login and password by default for a reason. Instead, a default Ubuntu install will use sudo.

Sudo is an alternative to giving people a root password in order to perform superuser duties. In a default Ubuntu install the person who installed the OS is given "sudo" permission by default.

Anybody with "sudo" permission may perform something "as a superuser" by pre-pending sudo to their command. For instance, to run apt-get dist-upgrade as a superuser, you could use:

sudo apt-get dist-upgrade
You will see this usage of sudo pretty much anywhere you read a tutorial about Ubuntu on the web. It's an alternative to doing this.

su
apt-get dist-upgrade
exit

With sudo, you choose in advance which users have sudo access. There is no need for them to remember a root password, as they use their own password. If you have multiple users, you can revoke one's superuser access just by removing their sudo permission, without needing to change the root password and notify everyone of a new password. You can even choose which commands a user is allowed to perform using sudo and which commands are forbidden for that user. And lastly, if there is a security breach it can in some cases leave a better audit trail showing which user account was compromised.

Sudo makes it easier to perform a single command with superuser privileges. With su, you permanently drop to a superuser shell which must be exited using exit or logout. This can lead to people staying in the superuser shell for longer than necessary just because it's more convenient than logging out and in again later.

With sudo, you still have the option of opening a permanent (interactive) superuser shell with the command:

sudo su
... and this can still be done without any root password, because sudo gives superuser privileges to the su command.

And similarly, instead of su - for a login shell you can use sudo su - or even sudo -i.

However when doing so you just need to be aware that you are acting as a superuser for every command. It's a good security principle not to stay as a superuser for longer than necessary, just to lessen the possibility of accidentally causing some damage to the system (without it, you can only damage files your user owns).

Just to clarify, you can, if you choose, give the root user a password allowing logins as root as described in @Oli's answer, if you specifically want to do things this way instead. I just wanted to let you know about the Ubuntu convention of preferring sudo instead and let you know that there is an alternative.

###########################################################################################

# check this file when dealing with SELinux
# all messages will be logged here
-rw-r----- 1 syslog adm 904 May  7 19:17 /var/log/auth.log
#########################################################################################
# Some useful commands for providing 'help' within the terminal environment.
1. Use man-pages of (man <command> -- these pages give a great over-view of the command and any additional arguments.
2. Use '--help' (E.g cp --help)-- This provides a quick reference of how a command should be structured. Args within [](square brackets) are optional. Args that are NOT in [] are required.
3. Use 'info' (info <command>) -- Much like the man pages, these provide info in addition to the 'man-pages'.
4. If you know of a command but can't rememeber the exact name, you can search the system. You do this by using the 'apropos' command (E.g apropos cp).

##############################################################################

Gzip and bzip2 are functionally equivalent. (There once was a bzip, but it seems to have completely vanished off the face of the world.) Other common compression formats are zip, rar and 7z; these three do both compression and archiving (packing multiple files into one). Here are some typical ratings in terms of speed, availability and typical compression ratio (note that these ratings are somewhat subjective, don't take them as gospel):

decompression speed (fast > slow): gzip, zip > 7z > rar > bzip2
compression speed (fast > slow): gzip, zip > bzip2 > 7z > rar
compression ratio (better > worse): 7z > rar, bzip2 > gzip > zip
availability (unix): gzip > bzip2 > zip > 7z > rar
availability (windows): zip > rar > 7z > gzip, bzip2
As you can see, there isn't a clear winner. If you want to rely on programs that are likely to be installed already, use zip on Windows (or if possible, self-extracting archives, as Windows doesn't ship with any of these) and gzip on unix. If you want maximum compression, use 7z.

Rar also has downside that, as far as I know, there is no free software that creates rar archives or that can unpack all rar archives. The other formats have free implementations and no (serious) patent claims.

########################################################################################

# Archiving a directory to a file using tar

tar -czvf [destination_name].tar.gz or .tgz(also common) [original dir]
***NOTE: arg 'f' MUST be the LAST ARGUMENT otherwise you will receive an error*****

E.g: tar -czvf jupyternotebookbackup.tar.gz jupyternotebook/
# now ls or ll the .tar.gz file and notice the file size... rather large and not practical for email or sending. In this case we need to compress the file using gzip.

command: gzip [*.tar.gz file]

# In order to view the contents of the tar file run:
tar -tf [*.tar.gz]

How to unzip .tgz file using the terminal
To extract a .tgz file with tar you need to use,

tar -xvzf /path/to/yourfile.tgz
where,

x for extract
v for verbose
z for gnuzip
f for file, should come at last just before file name.

#########################################################################################
RHCSA Flash Cards  #
********************

$ vncpasswd

This will prompt you to create a strong password that you will need to remember for connecting to your linux academy lab 
server via a VNC Client Application.
Before proceeding reboot your linux server.
After a few minutes you can ssh back to your server.

############################################################################################

What does this do?

cat [file] > [newfile].txt 

This is output redirection into a new file. This creates the file if it does not exist and writes the output to the file. *NOTE: If the file already exists then this will overwrite the file.

#############################################################################################

What does this command do?

$ ps aux >> processfile.txt

This creates process.txt if it doesn't exist and/or appends the output of ps aux into the file process.txt

##########################################################################################

Man Page for ls command

ls [OPTION]... [FILE]...

Explain the syntax


Anything within square brakets [..] is optional
the  .... means that the command accepts multiple options and multiple files

#########################################################################################


How do you redirect a STDERR output to a log file?

you do this by using the 2> (2 and a greater than sign)

$ [some_bad_command] 2> logfile.txt

again this creates the file if it doesn't exist.  However,  if the file does exist then you will need to use:
 $ [some_bad_command] 2>> logfile.txt
 to append the stderr output.

##########################################################################################

Hit Ctrl 'r' to issue a history of previous commands.

#########################################################################################

FILE TRANSFER THROUGH SSH USING 1. SCP or 2.SFTP
(Please read the man pages for these)

Both scp and sftp use the ssh port 22 because it is encrypted this is the safe way of file 
transfering. NOTE!!! 'Telnet' is unsecure and should be avoided if possible.


# scp [file...file...file] username@ip_address(:and specify where to put the files)
# (eg below.. transfering test1-4 into CentOS remote server and placing the files into the 
user's home directory.

$ scp test1 test2 test3 test4 user@52.90.15.86:~/

SFTP:

$ sftp username@ip_address

Once logged into remote server you are able to run most linux commands.

# transfers file from the REMOTE SERVER --> LOCAL HOST
# think... put file on LOCAL HOST
$ put file_name

# transfers file from the LOCAL HOST --> REMOTE SERVER
# think... get file from LOCAL HOST
$ get file_name

TO EXIT SFTP:
type: 'bye, exit or quit'




####################################################################################

RESTART SSH SERVICE

sudo /etc/init.d/ssh restart



# Using globs in Linux Red Hat

ls nameOfTheFile* - 
ls ?nameOfTheFile
ls [nam]meOfTheFile
ls [!te]meOfTheFile --> Negates(excludes) characters after '!' Can also be '^'(e.g [^na]meOfTheFile)
ls [0-10][0-10]NameOfTheFile


****COMMANDS TO KNOW****

$ service --status-all  

runs all init scripts, in alphabetical order, with the status command.   The  status
is  [ + ] for running services, [ - ] for stopped services and [ ? ] for services without a 'status' 
command. This option only calls status for sysvinit jobs; upstart jobs can be queried in a  similar  manner
with initctl list.


$ initctl list

allows a system administrator to communicate and interact with the Upstart init(8) daemon.

$ dmesg

is used to examine or control the kernel ring buffer.

The default action is to display all messages from the kernel ring buffer.

$ host

is a simple utility for performing DNS lookups. It is normally used
to convert names to IP addresses and vice versa. When no arguments or
options are given, host prints a short summary of its command line
arguments and options.


$ dig

(domain information groper) is a flexible tool for interrogating DNS
name servers. It performs DNS lookups and displays the answers that are
returned from the name server(s) that were queried. Most DNS
administrators use dig to troubleshoot DNS problems because of its
flexibility, ease of use and clarity of output. Other lookup tools tend to
have less functionality than dig.

$ systemctl

may be used to introspect and control the state of the "systemd"
system and service manager. Please refer to systemd(1) for an introduction
into the basic concepts and functionality this tool manages.

# to start a service run:
$ sytemctl start [service_name]

$ systemd 

systemd is a system and service manager for Linux operating systems. When
run as first process on boot (as PID 1), it acts as init system that
brings up and maintains userspace services.
For compatibility with SysV, if systemd is called as init and a PID that
is not 1, it will execute telinit and pass all command line arguments
unmodified. That means init and telinit are mostly equivalent when invoked
from normal login sessions. See telinit(8) for more information.

When run as a system instance, systemd interprets the configuration file
system.conf and the files in system.conf.d directories; when run as a user
instance, systemd interprets the configuration file user.conf and the
files in user.conf.d directories. See systemd-system.conf(5) for more
information.

###########################################################################################################################################

$ pgrep  

pgrep  looks  through the currently running processes and lists the process IDs which match the selection
criteria to stdout.  All the criteria have to match.  For example,

$ pgrep -u root sshd

 will only list the processes called sshd AND owned by root.  On the other hand,

$ pgrep -u root,daemon

will list the processes owned by root OR daemon.

pkill will send the specified signal (by default SIGTERM) to each process instead of listing them on std‐
 # This will look through the current running processes and search for 'httpd' pass the -l flag to list the name
$ pgrep httpd -l

# search all processes NOT owned by the root user. -v in this case returns the inverse. This is an inverse relationship.
$ pgrep -v -u root -l


Pkill

 pkill will send the specified signal (by default SIGTERM) to each process instead of listing them on std‐ out.


# to kill all processes on a particular service run:
																		$ pkill [name_of_service] (e.g httpd) -- This will kill any services associated with httpd, rather than using kill [PID #]


																		# (below) running kill -l will list out all of the different process kill options
																		# by default pkill if run with no args will default to 15(SIGTERM)-- this will kill the process cleanly and correctly allowing the process to finish tasks before closing.
																		# NOTE if we encounter a process that is hung/frozen or a prossible malious attack use 9(SIGKILL) to immediately terminate the process.

																		[root@centos andre]# kill -l
																		 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
																		  6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
																		  11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
																		  16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
																		  21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
																		  26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
																		  31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
																		  38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
																		  43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
																		  48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
																		  53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
																		  58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
																		  63) SIGRTMAX-1	64) SIGRTMAX

																		  STUDY THESE******

																		  1) SIGHUP-- 'Signal Hang-up': This hangs up the connection to the process, similar to clicking the 'x' in a window to close the process
																		  2) SIGINT--'Signal Interrupt' : This is equalvent to the keyboard input of 'ctrl+c' this kills the process by interruption.

3) SIGQUIT--'Signal Quit': Sends a signal to process causing it to quit. This allows the process to finish any closing tasks if needed.

15) SIGTERM--'Signal Terminate': (Pkill default) this will kill the process cleanly and correctly allowing the process to finish tasks before closing.

18) SIGCONT--'Signal Continue': Will stop a process and then restart it automatically

19) SIGSTOP--'Signal Stop': This forces a STOP to the process and allows the user to restart if needed.

20) SIGTSTP-- Sends a signal to a process that can be stopped but does not forcefully do it.


########################################################################################################################################

***HOW TO CLEANLY BOOT ANOTHER USER OFF THE SYSTEM***

AS ROOT: To view all user accounts on system run:


# in /etc/passwd file cut everything in the first column at the delimeter ':'
$ cut -d: -f1 /etc/passwd

# In order for this to work have a admin user on a physical machine as root. Add another user to the system with their own unique password

$ useradd archie
$ passwd archie
create password

On the root account, ssh into <user>@<server_ip> (e.g ssh archie@10.0.0.5)

Now, as archie sign-in and open vim. This will create the process when we look at the account using:


w - Show who is logged on and what they are doing.

SYNOPSIS
       w [options] user [...]

DESCRIPTION
       w  displays information about the users currently on the machine, and their processes.  The header shows,
       in this order, the current time, how long the system has been  running,  how  many  users  are  currently
       logged on, and the system load averages for the past 1, 5, and 15 minutes.

       The following entries are displayed for each user: login name, the tty name, the remote host, login time,
       idle time, JCPU, PCPU, and the command line of their current process.

       The JCPU time is the time used by all processes attached to the tty.  It does not include past background
       jobs, but does include currently running background jobs.

       The PCPU time is the time used by the current process, named in the "what" field.

TO KILL A PROCESS ON ANOTHER USER

$ pkill -t <terminal_window_id> (pts/*) -- find the particular user's tty and pkill it

Now, this will kill whatever application or process they are using instantly, however this will NOT log the user out.

***In order to completely and cleanly boot the user use the following:***

# first check on their processes and list them.

$ pgrep -u <user_name> -l (e.g pgrep -u frank -l)


# if the user is remoted into the server through ssh, simply kill sshd and this will kill the connection
# Remember to specify -u or else this will kill all sshd processes including any you as the ADMIN are using.

$ pkill -u <user_name> sshd

#####################################################################################################################################

Here we are going to create a while loop that will print a string of text("My Program") continuously every 1 second and send to a file called output.file in the home directory. The '&' at the end sends this process into a background task.

--To view background tasks run:
$ jobs

(while true; do echo -n "My Program" >> ~/output.file; sleep 1; done) &

EXAMPLE WITH BACKGROUND RUNNING TASK: 

[andre@centos ~]$ (while true; do echo -n "My Program" >> ~/output.file; sleep 1; done) &
[1] 31266
[andre@centos ~]$ jobs
[1]+  Running                 ( while true; do
    echo -n "My Program" >> ~/output.file; sleep 1;
done ) &


STOPPING THE PROCESS:

# Notice that the job id = [1]+, in order to pass the job id to -sigstop you must pass %(job_id_#) in this case 1 because there is only one job running.

[andre@centos ~]$ kill -sigstop %1

[1]+  Stopped                 ( while true; do
    echo -n "My Program" >> ~/output.file; sleep 1;
done )


STARTING A STOPPED PROCESS: Use -sigcont

[andre@centos ~]$ kill -sigcont %1
[andre@centos ~]$ jobs
[1]+  Running                 ( while true; do
    echo -n "My Program" >> ~/output.file; sleep 1;
done ) &

 #####################################################################################################################################

Nice priority: (Range = negative 20 - positive 19)

-20 = Highest priority
19 = Lowest priority

Any user can make a task lower priority
Only Root can make a task higher priority

EXAMPLES OF CHANGING PRIORITY:


# List all processor tasks, filter by pid(processor id), comm(command), and nice(nice level/priority) search for httpd
# as you see all the httpd tasks have a TOP priority of 0(zero).

[andre@centos ~]$ ps axo pid,comm,nice | grep httpd

 2007 httpd             0
 2009 httpd             0
 2010 httpd             0
 2011 httpd             0
 2012 httpd             0
 2013 httpd             0

# to change the nice level:

# this will change the level to priority 10.
$ nice -n 10 httpd

HOW TO CHANGE THE PRIORITY LEVEL ON A RUNNING SERVICE WITHOUT STOPPING IT?
FOR EXAMPLE A WEB SERVER...STOPPING IT WOULD BOOT ALL USERS LOGGED IN...THIS WOULD BE BAD.

# to change for a single process use:
$ renice -n [new_level] [pid] ---> renice -n 10 2011


HOW TO CHANGE NICE LEVEL RECURRSIVLY FOR ALL HTTPD PROCESSES.
-- In this case we need to use what's called a 'sub shell' this is identified by $()

# to change the level for all httpd processes

$ renice -n [new_level] $(pgrep [service_name/process]) ------> E.g $ renice -n 10 $(pgrep httpd)

So what is happening? The sub-shell is run first giving us all of our httpd processes. That output is then passed to renice which makes the change.

[root@centos andre]# ps axo pid,comm,nice | grep httpd

 2007 httpd             0
 2009 httpd             0
 2010 httpd             0
 2011 httpd             0
 2012 httpd             0
 2013 httpd             0

[root@centos andre]# renice -n 14 $(pgrep httpd)

2007 (process ID) old priority 0, new priority 14
2009 (process ID) old priority 0, new priority 14
2010 (process ID) old priority 0, new priority 14
2011 (process ID) old priority 0, new priority 14
2012 (process ID) old priority 0, new priority 14
2013 (process ID) old priority 0, new priority 14

[root@centos andre]# ps axo pid,comm,nice | grep httpd

 2007 httpd            14
 2009 httpd            14
 2010 httpd            14
 2011 httpd            14
 2012 httpd            14
 2013 httpd            14

#####################################################################################################################################

TO SEE HOW LONG A TASK TAKES TO EXECUTE RUN TIME PRIOR TO THE COMMAND

# to see how long a tar archive takes run:

$ time tar -czvf macbook2.tar.gz macbook2/

real	0m1.692s
user	0m1.636s
sys	0m0.069s


######################################################################################################################################

GET CPU INFO 

$ cat /proc/cpuinfo

The proc file system is a pseudo-file system which is used as an interface to kernel data structures.  It
is commonly mounted at /proc.  Most of it is read-only, but some  files  allow  kernel  variables  to  be
changed.


# get the number of processors specific to the machine

$ cat /proc/cpuinfo | grep "model name" | wc -l

####################################################################################################################################

Locate and Interpret System Log Files and Journals

# to see a particular process status run:
$ systemctl status <process_name> (e.g systemctl stauts httpd)

# to view a system configuration file with journalctl

$ journalctl _SYSTEM_UNIT=[configuration_file]

----> # To view the different types of configuration files
	located in /usr/lib/systemd -------> OR $ systemctl -t help

[root@centos ~]# systemctl -t help
Available unit types:
service
socket
busname
target
snapshot
device
mount
automount
swap
timer
path
slice
scope


# see user's ssh into system in real time
$ tail -f secure

# man systemd-journald

  systemd-journald is a system service that collects and stores logging data. It creates and maintains
       structured, indexed journals based on logging information that is received from a variety of sources:

       ·   Kernel log messages, via kmsg

       ·   Simple system log messages, via the libc syslog(3) call

       ·   Structured system log messages via the native Journal API, see sd_journal_print(4)

       ·   Standard output and standard error of system services

       ·   Audit records, via the audit subsystem

       The daemon will implicitly collect numerous metadata fields for each log messages in a secure and
       unfakeable way. See systemd.journal-fields(7) for more information about the collected metadata.

       Log data collected by the journal is primarily text-based but can also include binary data where
       necessary. All objects stored in the journal can be up to 2^64-1 bytes in size.

       By default, the journal stores log data in /run/log/journal/. Since /run/ is volatile, log data is lost
       at reboot. To make the data persistent, it is sufficient to create /var/log/journal/ where
       systemd-journald will then store the data.

       systemd-journald will forward all received log messages to the AF_UNIX/SOCK_DGRAM socket
       /run/systemd/journal/syslog, if it exists, which may be used by Unix syslog daemons to process the data
       further.

       See journald.conf(5) for information about the configuration of this service.

***The directory /run/log is essentially a temp file system unique to each boot up***

# to see the journal run:
$ journalctl
##################################################################################################################

INFORMATION ON THE BOOT PROCESS****

[root@centos ~]# systemd-analyze
Startup finished in 1.117s (kernel) + 2.181s (initrd) + 20.335s (userspace) = 23.635s

# To trouble shoot and see a particular configuration file during boot-up use:

[root@centos ~]# systemd-analyze blame

          5.361s NetworkManager-wait-online.service
          4.798s lvm2-monitor.service
          4.332s systemd-udev-settle.service
          4.104s dev-mapper-centos\x2droot.device
          2.464s lvm2-pvscan@8:3.service
          2.183s kdump.service
          1.424s systemd-udevd.service
          1.034s proc-fs-nfsd.mount
           947ms home.mount
           816ms systemd-tmpfiles-setup-dev.service
           810ms postfix.service
           696ms firewalld.service
           660ms NetworkManager.service
           573ms microcode.service
           455ms rhel-dmesg.service
           451ms systemd-journal-flush.service
           407ms rhel-readonly.service
           373ms gssproxy.service
           344ms systemd-sysctl.service
           307ms boot.mount
           305ms auditd.service
           291ms dmraid-activation.service
           283ms sys-kernel-debug.mount
           275ms network.service
           267ms libvirtd.service
           266ms systemd-tmpfiles-setup.service
           258ms systemd-random-seed.service
           218ms dev-mapper-centos\x2dswap.swap
           215ms polkit.service
           207ms plymouth-quit-wait.service
           207ms plymouth-quit.service
           200ms ModemManager.service
           193ms tuned.service
           188ms abrt-ccpp.service
           180ms mcelog.service
           176ms boot-efi.mount
           175ms dev-hugepages.mount
           174ms dev-mqueue.mount
           171ms rhel-import-state.service
           170ms nfs-config.service
           166ms systemd-remount-fs.service
           166ms rsyslog.service
           153ms sysstat.service


# Disabling systemctl services, disables the service from starting when reached in the appropriate target has been reached.

[root@centos ~]# systemctl disable httpd
[root@centos ~]# systemctl status httpd
● httpd.service - The Apache HTTP Server
   Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled; vendor preset: disabled)
   Active: inactive (dead)
     Docs: man:httpd(8)
           man:apachectl(8)

#########################################################################################################################################

FILE PERMISSION's

-rwxrw-r--    10    root   root 2048    Jan 13 07:11 afile.exe
?UUUGGGOOOS   00  UUUUUU GGGGGG ####    ^-- date stamp and file name are obvious ;-)
^ ^  ^  ^ ^    ^      ^      ^    ^
| |  |  | |    |      |      |    \--- File Size
| |  |  | |    |      |      \-------- Group Name (for example, Users, Administrators, etc)
| |  |  | |    |      \--------------- Owner Acct
| |  |  | |    \---------------------- Link count (what constitutes a "link" here varies)
| |  |  | \--------------------------- Alternative Access (blank means none defined, anything else varies)
| \--\--\----------------------------- Read, Write and Special access modes for [U]ser, [G]roup, and [O]thers (everyone else)
\------------------------------------- File type flag


##############################################################################################################################################################

What is the first digit in umask value?

The first digit 0 is not in use in your example. The umask reads from right to left and trailing zeros are ignored. It can however be used to set special permissions, such as sticky bit, Set GUID, Set UID as shown below.

0755  —- None of the special bits set
1755  —- Sticky bit set
2755  —- SGID bit set
4755  —- SUID bit set
You are correct that a umask of 0022 the will mask a default 777 (directory) permission to become 755 on newly created directories.

The octal numbering works similar to the first three sets: user, group, world/other.

The read/write/execute rwx values are represented in octal form with the corresponding values which can total a maximum of 7:

4 - Read 
2 - Write 
1 - Execute
So for 0755: 0 is ignored. 7 (4+2+1) equals read, write, and execute for the user/owner. And 5 (4+1) equals read and execute for the group, and the remaining 5 (also 4+1) gives read and execute permissions to other/world.


UNDERSTANDING UMASK

umask default can be seen using the command:

$ umask

umask default permissions on files == 666 (rw- User:Group:Other)
umask default permissions of directories == 777 (rwx-- User:Group:other)

##########################################################################################################################################

# Network configuration devices

# to view connected devices on machine
andre@Uhuru:/$ ls /sys/class/net/
lo  wlp2s0b1


# to show help options for adding a new network device( NOTE: is is just 'help' NOT --help)
andre@Uhuru:/$ nmcli con add help
Usage: nmcli connection add { ARGUMENTS | help }

ARGUMENTS := COMMON_OPTIONS TYPE_SPECIFIC_OPTIONS SLAVE_OPTIONS IP_OPTIONS [-- ([+|-]<setting>.<property> <value>)+]

  COMMON_OPTIONS:
                  type <type>
                  ifname <interface name> | "*"
                  [con-name <connection name>]
                  [autoconnect yes|no]
                  [save yes|no]
                  [master <master (ifname, or connection UUID or name)>]
                  [slave-type <master connection type>]

  TYPE_SPECIFIC_OPTIONS:
    ethernet:     [mac <MAC address>]
                  [cloned-mac <cloned MAC address>]
                  [mtu <MTU>]

    wifi:         ssid <SSID>
                  [mac <MAC address>]
                  [cloned-mac <cloned MAC address>]
                  [mtu <MTU>]
                  [mode infrastructure|ap|adhoc]

    wimax:        [mac <MAC address>]
                  [nsp <NSP>]

    pppoe:        username <PPPoE username>
                  [password <PPPoE password>]
                  [service <PPPoE service name>]
                  [mtu <MTU>]
                  [mac <MAC address>]

    gsm:          apn <APN>
                  [user <username>]
                  [password <password>]

    cdma:         [user <username>]
                  [password <password>]

    infiniband:   [mac <MAC address>]
                  [mtu <MTU>]
                  [transport-mode datagram | connected]
                  [parent <ifname>]
                  [p-key <IPoIB P_Key>]

    bluetooth:    [addr <bluetooth address>]
                  [bt-type panu|dun-gsm|dun-cdma]

    vlan:         dev <parent device (connection UUID, ifname, or MAC)>
                  id <VLAN ID>
                  [flags <VLAN flags>]
                  [ingress <ingress priority mapping>]
                  [egress <egress priority mapping>]
                  [mtu <MTU>]

    bond:         [mode balance-rr (0) | active-backup (1) | balance-xor (2) | broadcast (3) |
                        802.3ad    (4) | balance-tlb   (5) | balance-alb (6)]
                  [primary <ifname>]
                  [miimon <num>]
                  [downdelay <num>]
                  [updelay <num>]
                  [arp-interval <num>]
                  [arp-ip-target <num>]
                  [lacp-rate slow (0) | fast (1)]

    bond-slave:   master <master (ifname, or connection UUID or name)>

    team:         [config <file>|<raw JSON data>]

    team-slave:   master <master (ifname, or connection UUID or name)>
                  [config <file>|<raw JSON data>]

    bridge:       [stp yes|no]
                  [priority <num>]
                  [forward-delay <2-30>]
                  [hello-time <1-10>]
                  [max-age <6-40>]
                  [ageing-time <0-1000000>]
                  [multicast-snooping yes|no]
                  [mac <MAC address>]

    bridge-slave: master <master (ifname, or connection UUID or name)>
                  [priority <0-63>]
                  [path-cost <1-65535>]
                  [hairpin yes|no]

    vpn:          vpn-type vpnc|openvpn|pptp|openconnect|openswan|libreswan|ssh|l2tp|iodine|...
                  [user <username>]

    olpc-mesh:    ssid <SSID>
                  [channel <1-13>]
                  [dhcp-anycast <MAC address>]

    adsl:         username <username>
                  protocol pppoa|pppoe|ipoatm
                  [password <password>]
                  [encapsulation vcmux|llc]

    tun:          mode tun|tap
                  [owner <UID>]
                  [group <GID>]
                  [pi yes|no]
                  [vnet-hdr yes|no]
                  [multi-queue yes|no]

    ip-tunnel:    mode ipip|gre|sit|isatap|vti|ip6ip6|ipip6|ip6gre|vti6
                  remote <remote endpoint IP>
                  [local <local endpoint IP>]
                  [dev <parent device (ifname or connection UUID)>]

    macvlan:      dev <parent device (connection UUID, ifname, or MAC)>
                  mode vepa|bridge|private|passthru|source
                  [tap yes|no]

    vxlan:        id <VXLAN ID>
                  remote <IP of multicast group or remote address>
                  [local <source IP>]
                  [dev <parent device (ifname or connection UUID)>]
                  [source-port-min <0-65535>]
                  [source-port-max <0-65535>]
                  [destination-port <0-65535>]

  SLAVE_OPTIONS:
    bridge:       [priority <0-63>]
                  [path-cost <1-65535>]
                  [hairpin yes|no]

    team:         [config <file>|<raw JSON data>]

  IP_OPTIONS:
                  [ip4 <IPv4 address>] [gw4 <IPv4 gateway>]
                  [ip6 <IPv6 address>] [gw6 <IPv6 gateway>]


# to see a more detail version of currently connected devices
andre@Uhuru:/$ nmcli dev show
GENERAL.DEVICE:                         wlp2s0b1
GENERAL.TYPE:                           wifi
GENERAL.HWADDR:                         28:37:37:23:8D:D4
GENERAL.MTU:                            1500
GENERAL.STATE:                          100 (connected)
GENERAL.CONNECTION:                     Cuckoo
GENERAL.CON-PATH:                       /org/freedesktop/NetworkManager/ActiveConnection/3
IP4.ADDRESS[1]:                         192.168.149.74/21
IP4.GATEWAY:                            192.168.144.1
IP4.ROUTE[1]:                           dst = 172.24.6.17/32, nh = 192.168.144.1, mt = 600
IP4.ROUTE[2]:                           dst = 169.254.0.0/16, nh = 0.0.0.0, mt = 1000
IP4.DNS[1]:                             8.8.8.8
IP4.DNS[2]:                             8.8.4.4
IP4.DOMAIN[1]:                          sf.office.twttr.net
IP6.ADDRESS[1]:                         fe80::c53:ee58:77ea:c0f2/64
IP6.GATEWAY:                            

GENERAL.DEVICE:                         lo
GENERAL.TYPE:                           loopback
GENERAL.HWADDR:                         00:00:00:00:00:00
GENERAL.MTU:                            65536
GENERAL.STATE:                          10 (unmanaged)
GENERAL.CONNECTION:                     --
GENERAL.CON-PATH:                       --
IP4.ADDRESS[1]:                         127.0.0.1/8
IP4.GATEWAY:                            
IP6.ADDRESS[1]:                         ::1/128
IP6.GATEWAY:        


#########################################################################################################################################


What is DHCP?

Anyone with a basic knowledge of computer networking knows that for two hosts to communicate on the same network using TCP/IP model, both hosts need to have a unique IP address. There are two ways on how any given host on your network can obtain an IP address. 

One way is to manually configure the network interface and assign an IP address by hand. The manual network configuration is called static configuration, which means that host's IP address does not change its IP address unless changed manually by the user or system administrator. If your company network includes more than 1000 hosts, the job of configuring each host with a static IP address becomes tiresome and more importantly extremely inefficient. 

Another way to assign your network hosts with a proper IP address regardless of the actual network size is to assign an IP address to each host automatically. To perform an automatic host's IP configuration is where DHCP ( Dynamic Host Configuration Protocol ) comes handy. 

The DHCP protocol lets a DHCP client, that is your network host to lease network configuration parameters such as an IP address. In fact, lease parameters are not limited to IP address only as they may also include the following configuration settings:

IP addresses and network masks
Domain Names servers ( DNS )
Default Gateways
WINS servers
Syslog hosts
Proxy servers
NTP servers
X Font servers
Syslog hosts
Each network host configured to obtain an IP address dynamically via DHCP will upon boot send a DHCP request over the network ( by definition this is a broadcast of all 1's ) to discover whether there is a DHCP server available somewhere on the network and consequently ask for a network configuration. DHCP client is then obligated to maintain communication with DHCP server and renew its IP address regularly as dictated by IP address's lease time expiry. In case that DHCP client fails to renew its IP address ( disconnection, a host is turned off, etc. ) its IP address expires and DHCP server is free to lease this IP address to another DHCP client.

DHCP server keeps a record of all leased IP addresses and stores them in a file called dhcpd.leases within /var/lib/dhcp directory ( location of this file may vary depending on Linux system in use ). Having such a file allows DHCP server to keep track of all IP address leases even after the reboot or power failure. 

Here are some advantages of having a DHCP server connected to network:

No IP address conflicts. DHCP can guarantee that all hosts on the network have a unique IP address. DHCP server keeps a record of all IP addresses assigned and cross reference them with host's MAC addresses.
Based on the MAC address, DHCP allows for a fixed parameter configuration for a specific host
minimum local client network configuration, hence Increased efficiency.

##############################################################################################################################################

 Configure Networking and Hostname Resolution Statically or Dynamically: Hostname Configuration

***************************************************************************************************************

# to check the hostname search file
$ vim /etc/resolv.conf

# to view hostname

$ hostname

# to view hostname status
$ hostnamectl status
Static hostname: Uhuru
         Icon name: computer-laptop
           Chassis: laptop
        Machine ID: 6ad175eda8fe4f57a1a85a60d523fb11
           Boot ID: a1f028e9b22f4f11912c43d71e25033c
  Operating System: Ubuntu 16.04.4 LTS
            Kernel: Linux 4.4.0-127-generic
      Architecture: x86-64

# to change the current hostname and be persistent(survive a reboot)
$ hostnamectl set-hostname <new_hostname>

# to make sure the bash is updated run:
$ exec bash

######################################################################################

# Turning on networking and Wifi via command Line with (nmcli)


# turn on networking
root@Uhuru:~# nmcli 
agent       connection  device      general     help        monitor     networking  radio 
      
root@Uhuru:~# nmcli networking 
connectivity  help          off           on
            
root@Uhuru:~# nmcli networking on
root@Uhuru:~# nmcli 
agent       connection  device      general     help        monitor     networking  radio  

**************************************************************************************************     

# Turn on wifi

root@Uhuru:~# nmcli radio 
all   help  wifi  wwan  
root@Uhuru:~# nmcli radio 

all   help  wifi  wwan  
root@Uhuru:~# nmcli radio wifi 
help  off   on    

root@Uhuru:~# nmcli radio wifi on

###########################################################################################################


# edit network hosts configuration directly
# by default it is set to look internally(locally) and then externally

$ vim /etc/nsswitch.conf


*********************************************************

NAME
       getent - get entries from Name Service Switch libraries

SYNOPSIS
       getent [option]... database key...

DESCRIPTION
       The  getent command displays entries from databases supported by the Name Service Switch libraries,
       which are configured in /etc/nsswitch.conf.  If one or more key arguments are provided,  then  only
       the  entries that match the supplied keys will be displayed.  Otherwise, if no key is provided, all
       entries will be displayed (unless the database does not support enumeration).


#######################################################################################################################

Schedule Tasks Using at and cron
**********************************************************







